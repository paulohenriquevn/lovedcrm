#!/bin/bash
# üöÄ SQL Migration Tool - Super amig√°vel para LLM
#
# USO:
#   ./migrate check     # Ver migra√ß√µes pendentes
#   ./migrate apply     # Aplicar migra√ß√µes pendentes
#   ./migrate status    # Ver status atual
#   ./migrate init      # Criar banco do zero (DEV)

set -e

# Database connection - DATABASE_URL first, then individual variables, then .env fallback
if [ -n "$DATABASE_URL" ]; then
    # Parse DATABASE_URL (format: postgresql://user:pass@host:port/dbname)
    DB_USER=$(echo "$DATABASE_URL" | sed -n 's|^postgresql://\([^:]*\):.*|\1|p')
    DB_PASS=$(echo "$DATABASE_URL" | sed -n 's|^postgresql://[^:]*:\([^@]*\)@.*|\1|p')
    DB_HOST=$(echo "$DATABASE_URL" | sed -n 's|^postgresql://[^@]*@\([^:]*\):.*|\1|p')
    DB_PORT=$(echo "$DATABASE_URL" | sed -n 's|^postgresql://[^@]*@[^:]*:\([^/]*\)/.*|\1|p')
    DB_NAME=$(echo "$DATABASE_URL" | sed -n 's|^postgresql://[^/]*/\(.*\)|\1|p')
else
    # Fall back to individual environment variables
    DB_HOST=${DATABASE_HOST:-}
    DB_PORT=${DATABASE_PORT:-}
    DB_NAME=${DATABASE_NAME:-}
    DB_USER=${DATABASE_USER:-}
    DB_PASS=${DATABASE_PASSWORD:-}
fi

# Debug: show environment variables (when MIGRATE_DEBUG is set)
if [ "$MIGRATE_DEBUG" = "1" ]; then
    echo "üîç Debug: Environment variables:"
    echo "  DATABASE_HOST=$DATABASE_HOST"
    echo "  DATABASE_PORT=$DATABASE_PORT"
    echo "  DATABASE_NAME=$DATABASE_NAME"
    echo "  DB_HOST=${DB_HOST}"
    echo "  DB_PORT=${DB_PORT}"
    echo "  DB_NAME=${DB_NAME}"
fi

# If not set via environment, try loading from .env
if [ -z "$DB_HOST" ] && [ -f ../.env ]; then
    if [ "$MIGRATE_DEBUG" = "1" ]; then
        echo "üîç Debug: Loading from ../.env file"
    fi
    export $(grep -v '^#' ../.env | xargs)
    DB_HOST=${DATABASE_HOST:-localhost}
    DB_PORT=${DATABASE_PORT:-5433}
    DB_NAME=${DATABASE_NAME:-saas_starter}
    DB_USER=${DATABASE_USER:-postgres}
    DB_PASS=${DATABASE_PASSWORD:-postgres}
else
    # Set defaults for missing env vars
    DB_HOST=${DB_HOST:-localhost}
    DB_PORT=${DB_PORT:-5433}
    DB_NAME=${DB_NAME:-saas_starter}
    DB_USER=${DB_USER:-postgres}
    DB_PASS=${DB_PASS:-postgres}
fi

# Debug: show final values (when MIGRATE_DEBUG is set)
if [ "$MIGRATE_DEBUG" = "1" ]; then
    echo "üîç Debug: Final connection values:"
    echo "  DB_HOST=$DB_HOST"
    echo "  DB_PORT=$DB_PORT"
    echo "  DB_NAME=$DB_NAME"
    echo "  DB_USER=$DB_USER"
fi

PGPASSWORD=$DB_PASS
export PGPASSWORD

# Database connection string
PSQL_CMD="psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -q"
MIGRATIONS_DIR="."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# Get current schema version
get_current_version() {
    $PSQL_CMD -t -c "
        SELECT COALESCE(MAX(version), 0) 
        FROM schema_versions 
    " 2>/dev/null || echo "0"
}

# Get available migrations (only numbered ones)
get_available_migrations() {
    ls $MIGRATIONS_DIR/[0-9]*.sql 2>/dev/null | sort | sed 's/.*\///g' || true
}

# Get pending migrations
get_pending_migrations() {
    current_version=$(get_current_version)
    available=$(get_available_migrations)
    
    for migration in $available; do
        version=$(echo $migration | grep -o '^[0-9]\+')
        if [ "$version" -gt "$current_version" ]; then
            echo $migration
        fi
    done
}

# Check database connection
check_connection() {
    if ! $PSQL_CMD -c "SELECT 1;" >/dev/null 2>&1; then
        log_error "Cannot connect to database"
        log_info "Check your database connection settings:"
        log_info "  Host: $DB_HOST:$DB_PORT"
        log_info "  Database: $DB_NAME"
        log_info "  User: $DB_USER"
        exit 1
    fi
}

# Show status
cmd_status() {
    check_connection
    
    current_version=$(get_current_version)
    available_migrations=$(get_available_migrations | wc -l)
    pending_migrations=$(get_pending_migrations | wc -l)
    
    log_info "üìä Migration Status"
    echo "  Current version: $current_version"
    echo "  Available migrations: $available_migrations"
    echo "  Pending migrations: $pending_migrations"
    
    if [ "$pending_migrations" -gt 0 ]; then
        log_warning "Database needs updates"
    else
        log_success "Database is up to date"
    fi
}

# Check pending migrations
cmd_check() {
    check_connection
    
    pending=$(get_pending_migrations)
    
    if [ -z "$pending" ]; then
        log_success "No pending migrations"
        return 0
    fi
    
    log_info "üìã Pending migrations:"
    for migration in $pending; do
        echo "  üîÑ $migration"
    done
    
    log_info "üí° Run './migrate apply' to apply these migrations"
}

# Apply pending migrations
cmd_apply() {
    check_connection
    
    pending=$(get_pending_migrations)
    
    if [ -z "$pending" ]; then
        log_success "No migrations to apply"
        return 0
    fi
    
    log_info "üöÄ Applying migrations..."
    
    for migration in $pending; do
        log_info "‚è≥ Applying $migration..."
        
        if $PSQL_CMD -f "$MIGRATIONS_DIR/$migration"; then
            log_success "Applied $migration"
        else
            log_error "Failed to apply $migration"
            exit 1
        fi
    done
    
    log_success "All migrations applied successfully! üéâ"
}

# Initialize database (DEV only)
cmd_init() {
    log_warning "‚ö†Ô∏è  This will DROP ALL TABLES and recreate the database!"
    read -p "Are you sure? Type 'yes' to continue: " confirm
    
    if [ "$confirm" != "yes" ]; then
        log_info "Cancelled"
        exit 0
    fi
    
    check_connection
    
    log_info "üîÑ Dropping all tables..."
    $PSQL_CMD -c "
        DROP SCHEMA public CASCADE;
        CREATE SCHEMA public;
        GRANT ALL ON SCHEMA public TO $DB_USER;
        GRANT ALL ON SCHEMA public TO public;
    "
    
    log_info "üöÄ Applying all migrations..."
    cmd_apply
    
    log_success "Database initialized successfully! üéâ"
}

# Load test data
cmd_test_setup() {
    check_connection
    
    log_info "üß™ Loading test data..."
    if $PSQL_CMD -f "test-setup.sql"; then
        log_success "Test data loaded successfully!"
    else
        log_error "Failed to load test data"
        exit 1
    fi
}

# Load development seeds
cmd_dev_seeds() {
    check_connection
    
    log_info "üå± Loading development seeds..."
    if $PSQL_CMD -f "dev-seeds.sql"; then
        log_success "Development seeds loaded successfully!"
    else
        log_error "Failed to load development seeds"
        exit 1
    fi
}

# Clean database
cmd_clean() {
    log_warning "‚ö†Ô∏è  This will DELETE ALL DATA but keep the schema!"
    read -p "Are you sure? Type 'yes' to continue: " confirm
    
    if [ "$confirm" != "yes" ]; then
        log_info "Cancelled"
        exit 0
    fi
    
    check_connection
    
    log_info "üßπ Cleaning database..."
    if $PSQL_CMD -f "clean-db.sql"; then
        log_success "Database cleaned successfully!"
    else
        log_error "Failed to clean database"
        exit 1
    fi
}

# Show help
cmd_help() {
    echo "üöÄ SQL Migration Tool"
    echo ""
    echo "MIGRATION COMMANDS:"
    echo "  ./migrate check       # Show pending migrations"
    echo "  ./migrate apply       # Apply pending migrations"
    echo "  ./migrate status      # Show current status"
    echo "  ./migrate init        # Initialize database (‚ö†Ô∏è  DROPS ALL DATA)"
    echo ""
    echo "DATA COMMANDS:"
    echo "  ./migrate test-setup  # Load test data (for E2E tests)"
    echo "  ./migrate dev-seeds   # Load development seeds"
    echo "  ./migrate clean       # Clean all data (‚ö†Ô∏è  KEEPS SCHEMA)"
    echo ""
    echo "OTHER:"
    echo "  ./migrate help        # Show this help"
    echo ""
    echo "ADDING NEW MIGRATION:"
    echo "  1. Create: 002_add_field.sql"
    echo "  2. Write SQL with version tracking:"
    echo "     INSERT INTO schema_versions (version, description)"
    echo "     VALUES (2, 'Add new field');"
    echo "  3. Run: ./migrate apply"
}

# Main command dispatcher
case "${1:-help}" in
    "check")      cmd_check ;;
    "apply")      cmd_apply ;;
    "status")     cmd_status ;;
    "init")       cmd_init ;;
    "test-setup") cmd_test_setup ;;
    "dev-seeds")  cmd_dev_seeds ;;
    "clean")      cmd_clean ;;
    "help")       cmd_help ;;
    *)            cmd_help ;;
esac